<?xml version='1.0' encoding='UTF-8'?>
<rss version='2.0' xmlns:atom='http://www.w3.org/2005/Atom'>
<channel>
<atom:link href='http://blogawesome.com/' rel='self' type='application/rss+xml'/>
<title>
Physics. Computers. Code.
</title>
<link>
http://blogawesome.com/
</link>
<description>
A place to share my knowledge
</description>
<lastBuildDate>
Mon, 03 Oct 2016 01:21:52 -0400
</lastBuildDate>
<generator>
clj-rss
</generator>
<item>
<guid>
http://blogawesome.com/posts-output/wordcal/
</guid>
<link>
http://blogawesome.com/posts-output/wordcal/
</link>
<title>
WordCal - A Python Script
</title>
<description>
&lt;p&gt;&lt;h2&gt;What is the WordCal Python Script?&lt;/h2&gt; It is a python script which counts the number of times a particular character appears in a file. As shown by the below image the script provides the percentage that a character appears. &lt;br /&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://defunsm.github.io/img/wordcal2.png&quot; alt=&quot;WordCal Python Script Analyzer&quot; /&gt;&lt;/p&gt;&lt;p&gt;&lt;h3&gt;How to use the WordCal Script?&lt;/h3&gt;&lt;/p&gt;&lt;p&gt;Using the wordcal script is relatively simple. &lt;br /&gt;&lt;br /&gt; 1) Install the &lt;a href=&quot;https://github.com/defunSM/wordcal&quot; target=&quot;_blank&quot;&gt;wordcal.py&lt;/a&gt; file from GitHub.&lt;/p&gt;&lt;p&gt;2) Enter your favorite terminal.&lt;/p&gt;&lt;p&gt;3) Enter the following...&lt;/p&gt;&lt;p&gt;&lt;code&gt;$ python wordcal.py&lt;/code&gt;&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;This should lead you to the following prompt...&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://defunsm.github.io/img/wordcal1.png&quot; alt=&quot;WordCal Python Script&quot; /&gt;&lt;/p&gt;&lt;p&gt;Once prompted you are given two options at the start. The two options are as follows...&lt;/p&gt;&lt;p&gt;1) Analyze a file&lt;/p&gt;&lt;p&gt;2) Quit Program &lt;br /&gt;&lt;br /&gt; To select an option enter 1 or 2.&lt;/p&gt;&lt;p&gt;Entering &lt;code&gt;1&lt;/code&gt; brings you to the next prompt asking for the filename.&lt;/p&gt;&lt;p&gt;Entering &lt;code&gt;2&lt;/code&gt; exits the program returning you to the terminal without doing anything.&lt;/p&gt;&lt;p&gt;After pressing &lt;code&gt;1&lt;/code&gt; enter the name of the file you want to analyze. &lt;/p&gt;&lt;p&gt;Enter the full file name including any extensions that the file may have.&lt;/p&gt;&lt;p&gt;For example if you wanted to use the script on a file called &quot;file.txt&quot; ... &lt;br /&gt;&lt;br /&gt; &lt;code&gt;&gt; file.txt&lt;/code&gt; &lt;br /&gt;&lt;br /&gt; &lt;h2&gt;How does the WordCal Python Script work?&lt;/h2&gt;&lt;/p&gt;&lt;p&gt;The script runs from the terminal and asks for a filename. Entering the filename will access the file and turn the contents of the file into an array. Several functions in the program will sort out the contents of the file. Eventually returning the amount of times a character appears and the percentage. &lt;br /&gt;&lt;br /&gt; &lt;h4&gt;Functions used in the script:&lt;/h4&gt;&lt;/p&gt;&lt;p&gt;&lt;code&gt;convert&lt;i&gt;File&lt;/i&gt;to_Array(filename) &lt;/code&gt;&lt;/p&gt;&lt;p&gt;This function takes an open file in read mode and turns the contents into an array. Each line of the file is an element in the array.&lt;/p&gt;&lt;p&gt;For example if this was a text file called file.txt ...&lt;/p&gt;&lt;p&gt;&lt;code&gt;This is the first line This is the second line&lt;/code&gt; &lt;br /&gt;&lt;br /&gt; You can use &lt;code&gt;convert&lt;i&gt;File&lt;/i&gt;to_Array()&lt;/code&gt; to convert a file into an array by ...&lt;/p&gt;&lt;p&gt;&lt;code&gt;from wordcal import convert&lt;i&gt;File&lt;/i&gt;to_Array&lt;/code&gt;&lt;/p&gt;&lt;p&gt;&lt;code&gt;filename = open('file.txt', 'r')&lt;/code&gt;  &lt;code&gt;myarray = convert&lt;i&gt;File&lt;/i&gt;to_Array(filename)&lt;/code&gt;   &lt;/p&gt;&lt;p&gt;&lt;code&gt;print(myarray) &lt;code&gt;filename.close()&lt;/code&gt;&lt;/code&gt; &lt;br /&gt;&lt;br /&gt; &lt;strong&gt;Note:&lt;/strong&gt; You can open the file in 'w+' mode as well since it doesn't trancuate the file. However opening in 'w' will produce an empty array since opening a file in 'w' in python will trancuate the file first and won't preserve the file. When importing do not add the .py extension or it won't import and make sure that the wordcal.p is within the same directory. &lt;br /&gt;&lt;br /&gt; Now running the new code would result in a output to the terminal as such ...&lt;/p&gt;&lt;p&gt;&lt;code&gt; ['This is the first line', 'This is the second line'] &lt;/code&gt;&lt;/p&gt;&lt;p&gt;Notice that this is the whole line which may be what your looking for. However if you want single characters you would have to use &lt;code&gt;sorting_algorithm()&lt;/code&gt;. &lt;br /&gt;&lt;br /&gt; What the &lt;code&gt;sorting_algorithm()&lt;/code&gt; function does is it adds an character from an element to an array. So all you would have to do is place myarray into the function and change the print argument so it prints the newarray ...&lt;/p&gt;&lt;p&gt;&lt;code&gt;from wordcal import convert&lt;i&gt;File&lt;/i&gt;to_Array&lt;/code&gt; &lt;code&gt;from wordcal import sorting_algorithm&lt;/code&gt;&lt;/p&gt;&lt;p&gt;&lt;code&gt;filename = open('file.txt', 'r')&lt;/code&gt;  &lt;code&gt;myarray = convert&lt;i&gt;File&lt;/i&gt;to_Array(filename)&lt;/code&gt;  &lt;code&gt;newarray = sorting_algorithm(myarray)&lt;/code&gt;&lt;/p&gt;&lt;p&gt;&lt;code&gt;print(newarray) &lt;code&gt;filename.close()&lt;/code&gt;&lt;/code&gt; &lt;br /&gt;&lt;br /&gt; &lt;strong&gt;Note:&lt;/strong&gt; You can do &lt;code&gt;from wordcal import *&lt;/code&gt; which will import all the functions.  However this is generally discouraged and is considered bad practice specially with larger modules that you may import. &lt;br /&gt;&lt;br /&gt; You should have gotten an array with a lot of elements such as the following ...&lt;/p&gt;&lt;p&gt;&lt;code&gt;['T', 'h', 'i', 's', ' ', 'i', 's', ' ', 't', 'h', 'e', ' ', 'f', 'i', 'r', 's', 't', ' ', 'l', 'i', 'n', 'e', 'T', 'h', 'i', 's', ' ', 'i', 's', ' ', 't', 'h', 'e', ' ', 's', 'e', 'c', 'o', 'n', 'd', ' ', 'l', 'i', 'n', 'e']&lt;/code&gt; &lt;br /&gt;&lt;br /&gt; Now we have each character in the array. We now make a dict using &lt;code&gt;noduplicate()&lt;/code&gt; passing the function the new array as an argument. Now we can use &lt;code&gt;noduplicate()&lt;/code&gt; to print the data of the noduparray returned by &lt;code&gt;noduplicate()&lt;/code&gt;. &lt;br /&gt;&lt;br /&gt; &lt;code&gt;from wordcal import convert&lt;i&gt;File&lt;/i&gt;to_Array from wordcal import sorting_algorithm from wordcal import noduplicate from wordcal import analyze_data&lt;/code&gt;&lt;/p&gt;&lt;p&gt;&lt;code&gt;filename = open('file.txt', 'r') myarray = convert&lt;i&gt;File&lt;/i&gt;to_Array(filename) newarray = sorting_algorithm(myarray) noduparray = noduplicate(newarray)&lt;/code&gt;&lt;/p&gt;&lt;p&gt;&lt;code&gt;analyze_data(noduparray)&lt;/code&gt;&lt;/p&gt;&lt;p&gt;&lt;code&gt;filename.close()&lt;/code&gt; &lt;br /&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; That the &lt;code&gt;analyze_data()&lt;/code&gt; is not actually analyzing the data but really formating the data so that it is easy to read and prints.&lt;/p&gt;&lt;p&gt;That should produce sometime similar to the top image displaying the percentage of each character.&lt;/p&gt; 
</description>
<enclosure>

</enclosure>
<pubDate>
Sun, 02 Oct 2016 00:00:00 -0400
</pubDate>
</item>
<item>
<guid>
http://blogawesome.com/posts-output/smchat/
</guid>
<link>
http://blogawesome.com/posts-output/smchat/
</link>
<title>
SMChat
</title>
<description>
&lt;p&gt;&lt;h3&gt;What is SMChat?&lt;/h3&gt; &lt;hr&gt;&lt;/hr&gt; SMChat is a clojure coded graphical user interface (GUI) using the SeeSaw Library.&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://defunsm.github.io/img/smchat1.jpeg&quot; alt=&quot;SeeSaw Clojure nrepl&quot; /&gt;&lt;/p&gt;&lt;p&gt;&lt;h3&gt;What features does SMChat have?&lt;/h3&gt; &lt;hr&gt;&lt;/hr&gt; SMChat is still largely unfinished and being worked on.&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Clearing Messages&lt;/li&gt;&lt;li&gt;Changing Prompt&lt;/li&gt;&lt;li&gt;Font Color&lt;/li&gt;&lt;li&gt;Theme&lt;/li&gt;&lt;li&gt;Login Feature&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://defunsm.github.io/img/smchat2.jpeg&quot; alt=&quot;clojure&quot; /&gt;&lt;/p&gt;&lt;p&gt;&lt;h3&gt;What lies in the future for SMChat?&lt;/h3&gt; &lt;hr&gt;&lt;/hr&gt;&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Implementing chatbots.&lt;/li&gt;&lt;li&gt;A clear registration.&lt;/li&gt;&lt;li&gt;Access to SMChat through a web browser.&lt;/li&gt;&lt;li&gt;Creating a SMChat version for Linux.&lt;/li&gt;&lt;li&gt;A ton more.&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;h3&gt;Where can I go and download SMChat?&lt;/h3&gt; &lt;hr&gt;&lt;/hr&gt; You can find SMChat for Windows &lt;a href='https://github.com/defunSM/smchat/releases'&gt;here&lt;/a&gt;.&lt;/p&gt;
</description>
<enclosure>

</enclosure>
<pubDate>
Tue, 27 Sep 2016 00:00:00 -0400
</pubDate>
</item>
<item>
<guid>
http://blogawesome.com/posts-output/haskellpart1-ghci/
</guid>
<link>
http://blogawesome.com/posts-output/haskellpart1-ghci/
</link>
<title>
Haskell - Loading functions into GHCI (Part 1)
</title>
<description>
 &lt;p&gt;The way you identify a file to be haskell code is by adding a &lt;i&gt;.hs&lt;/i&gt; tag at the end of the file. So make a file called ex1.hs and open up a &lt;i&gt;ghci&lt;/i&gt;. &lt;/p&gt;&lt;p&gt;Before we go any further I want to distinguish when I am typing into the &lt;i&gt;ghci&lt;/i&gt; which will be identified with the &lt;code&gt;Prelude&gt;&lt;/code&gt; which means I am telling you to type into the &lt;i&gt;ghci&lt;/i&gt;. If there is a &lt;code&gt;$&lt;/code&gt; this means you are typing into your terminal. When there is no &lt;code&gt;Prelude&gt;&lt;/code&gt; and &lt;code&gt;$&lt;/code&gt; that means type into whatever text editor you happen to be using onto the ex1.hs file. &lt;/p&gt;&lt;p&gt;Making the ex1.hs using touch. Or however else you may prefer to make a file.&lt;/p&gt;&lt;pre&gt;&lt;code&gt;$ touch ex1.hs 
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Open up a ghci. I suggest you get a little familiar with the ghci since you will be spending a bit of time on it and to do that you can type &lt;code&gt;:?&lt;/code&gt; to view some options for the ghci.&lt;/p&gt;&lt;pre&gt;&lt;code&gt;$ ghci 
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Now that you have a ghci up and running lets write some code into ex1.hs and later we can load it into the ghci using :load ex1.hs and afterwards we can use :reload every time we edit ex1.hs. Now lets start with a pythagorean theorem to start off things. If you go back to your middle school and remember that a&lt;sup&gt;2&lt;/sup&gt; + b&lt;sup&gt;2&lt;/sup&gt; = c&lt;sup&gt;2&lt;/sup&gt; which is basically what we are going to be writing. In a lot of ways Haskell is very much just like math.&lt;/p&gt;&lt;pre&gt;&lt;code&gt;{- ################################################
        ex1.hs
        defunSM, Sept 2016.
        Haskell Part 1
################################################## -}

pythagorean :: Float -&amp;gt; Float -&amp;gt; Float   {-- Notice that there are two arguments pythagorean is taking a and b. --}
pythagorean a b = sqrt &amp;#40;a &amp;#94; 2 + b &amp;#94; 2&amp;#41;  
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The first line is identifying the type that pythagorean will recieve. In this case it'll recieve two Floats and the out put will be a Float. We do this since Haskell is statically typed and that the function can know before hand what to expect and doing this allows us to reuse our function later on.&lt;/p&gt;&lt;p&gt;Also to have comments you can do curly brackets and a dash like so {- this is a comment -}.&lt;/p&gt;&lt;p&gt;So now we can load our function by heading to the ghci which hopefully you still have running if not you can just run ghci again in the same directory of your ex1.hs file and type in the following to load pythagorean into the ghci. Once you used &lt;code&gt;:load&lt;/code&gt; you can now just use &lt;code&gt;:reload&lt;/code&gt; and it'll just update the functions you have in your file.&lt;/p&gt;&lt;pre&gt;&lt;code&gt;Prelude&amp;gt; :load ex1.hs
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;You should see Ok, Modules Loaded: Main. Meaning you're golden and no errors in your code. So now you can type the following to use pythagorean...&lt;/p&gt;&lt;pre&gt;&lt;code&gt;Prelude&amp;gt; pythagorean 3 4
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Now lets look at how to construct a factorial which is rather an easy one two liner in haskell.&lt;/p&gt;&lt;pre&gt;&lt;code&gt;factorial :: Integer -&amp;gt; Integer
factorial n = if n &amp;gt; 0 then n &amp;#42; factorial &amp;#40;n-1&amp;#41; else 1
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;factorial takes one argument than than checks if it is greater than 0 and if it is than it does n * factorial (n-1) otherwise its 1. This takes advantage of recursion calling itself. Now you can reload the file into ghci using &lt;code&gt;:reload&lt;/code&gt;. &lt;/p&gt;&lt;pre&gt;&lt;code&gt;Prelude&amp;gt; :reload 
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;And use factorial 5 to check that it works.&lt;/p&gt;&lt;pre&gt;&lt;code&gt;Prelude&amp;gt; factorial 5
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Now lets look at how to use guards in Haskell which are like conditionals. Lets look at this example of identifying if a quadradic has real roots. If you remember the quadradic equation you might remember that the discriminant is used to determine if a quadradic has real roots. So by using conditions and checking if the discriminant is positive, 0 or negative. Positive being two real numbers, zero being one real number and negative being no real numbers and only imginary roots. a will be the cofficient to the square term, b being the cofficent to the first power and c is the constant.&lt;/p&gt;&lt;pre&gt;&lt;code&gt;numberOfRoots :: Integer-&amp;gt; Integer-&amp;gt; Integer -&amp;gt; Int
numberOfRoots a b c
              | &amp;#40;b &amp;#94; 2 &amp;gt; 4 &amp;#42; b &amp;#42; c&amp;#41; = 2    
              | &amp;#40;b &amp;#94; 2 == 4 &amp;#42; b &amp;#42; c&amp;#41; = 1
              | &amp;#40;b &amp;#94; 2 &amp;lt; 4 &amp;#42; b &amp;#42; c&amp;#41; = 0
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Notice that to use guards each case is started on a new line with the | which is how you state each condition. Guards are very important in Haskell and can allow you to systemically go through and do different manipulations based on the arguments. However sometimes it isn't possible to account for all of the conditions so there in that case you can use otherwise. So you could have written the numberOfRoots function like this. You can check this works out actually in the &lt;i&gt;ghci&lt;/i&gt; by giving numberOfRoots three arguments.&lt;/p&gt;&lt;pre&gt;&lt;code&gt;numberOfRoots :: Integer-&amp;gt; Integer-&amp;gt; Integer -&amp;gt; Int
numberOfRoots a b c
              | &amp;#40;b &amp;#94; 2 &amp;gt; 4 &amp;#42; b &amp;#42; c&amp;#41; = 2    
              | &amp;#40;b &amp;#94; 2 == 4 &amp;#42; b &amp;#42; c&amp;#41; = 1
              | otherwise = 0
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;As you may begin to comprend now Haskell allows you to do computational math rather well and probably help you do your math homework I know it has for me.&lt;/p&gt; 
</description>
<enclosure>

</enclosure>
<pubDate>
Mon, 26 Sep 2016 00:00:00 -0400
</pubDate>
</item>
<item>
<guid>
http://blogawesome.com/posts-output/intro-to-haskell/
</guid>
<link>
http://blogawesome.com/posts-output/intro-to-haskell/
</link>
<title>
Haskell - Introduction
</title>
<description>
&lt;p&gt;&lt;a href='https://www.haskell.org/'&gt;Haskell&lt;/a&gt; is a purely functional programming language, statically typed, and lazy. &lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://defunsm.github.io/img/haskellimg.png&quot; alt=&quot;nosideeffects&quot; /&gt;&lt;/p&gt;&lt;p&gt;Purely Functional being every function in haskell is a function in a mathematical sense. Meaning there is no side effects and a function recieving an argument will always do the same thing. This is very different from object oriented programs which is all about mutating data. Since Haskell is a Pure functional programming language you can not mutate variables.&lt;/p&gt;&lt;p&gt;GHC is the compiler behind the Haskell language. You'll be testing out most of your code on a repl called ghci. The GHC is actually one behind C in terms of the fastest compilers.&lt;/p&gt;&lt;p&gt;If you haven't already take a look at their website and download the Haskell Platform which includes GHC, Cabal and some other tools along with a set of libraries &lt;a href='https://www.haskell.org/downloads'&gt;here&lt;/a&gt;.&lt;/p&gt;&lt;p&gt;Haskell is often times known to be the elite functional programming language as it is designed with mathemathics in mind. Haskell is named after logician Haskell Curry and his books regarding logic. However that doesn't mean that you can only do math in Haskell. &lt;/p&gt;&lt;p&gt;It is said that learning Haskell will however improve programming skills in general and open a new way of seeing and viewing code. Code in Haskell is brief and since it is pure it is easy to reuse code in Haskell. &lt;/p&gt;&lt;p&gt;Like C Haskell is a strong static typed language but unlike C garbage collection is handled implictly so you dont have to worry about those lingering pointers.&lt;/p&gt;&lt;p&gt;So after you have downloaded the Haskell platform. Go ahead open up the GHCI by the following...&lt;/p&gt;&lt;pre&gt;&lt;code&gt;ghci
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;And type ...&lt;/p&gt;&lt;pre&gt;&lt;code&gt;putStrLn &amp;quot;My first line of code in Haskell!&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;You have written a line of code in Haskell!&lt;/p&gt;
</description>
<enclosure>

</enclosure>
<pubDate>
Sun, 25 Sep 2016 00:00:00 -0400
</pubDate>
</item>
<item>
<guid>
http://blogawesome.com/posts-output/Using_swingpart3/
</guid>
<link>
http://blogawesome.com/posts-output/Using_swingpart3/
</link>
<title>
Graphics using Quil in Clojure (Part 3)
</title>
<description>
 &lt;p&gt;Since we done a few examples of Quil already. I would like to show how to utilize states and this demonstration is a lot more prettier than the previous ones.&lt;/p&gt;
</description>
<enclosure>

</enclosure>
<pubDate>
Sat, 24 Sep 2016 00:00:00 -0400
</pubDate>
</item>
<item>
<guid>
http://blogawesome.com/posts-output/basics-of-clojure5/
</guid>
<link>
http://blogawesome.com/posts-output/basics-of-clojure5/
</link>
<title>
Basics of Clojure - Watching an Atom (Part 5)
</title>
<description>
&lt;p&gt;Watching an Atom is exactly what it sounds like. Adding a Watch on an Atom keeps track of your atom and monitors them and when a specific condition is met it will trigger some function and alert you to the change.&lt;/p&gt;&lt;p&gt;Lets say we have our player that starts off with 100 health and when he reaches zero health we want to be notified that the game is over. The way we would go about this is first by creating an atom for the player. We already learned this in part 4.&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&amp;#40;def player &amp;#40;atom {:hp 100}&amp;#41;&amp;#41; ;; creates the player health at 100.
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Now we need a function that will lower the health of the player. We'll call this player-damage.&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&amp;#40;defn player-damage &amp;#91;val&amp;#93;
  &amp;#40;swap! player update-in &amp;#91;:hp&amp;#93; - val&amp;#41;&amp;#41; ;; lowers the health of the player.
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Now that we have a way to lower the player's health we can now monitor the atom as we change the player's health. The new part where we create a watch for out atom. This is done by the add-watch function.&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&amp;#40;defn watch-health &amp;#91;key watch old new&amp;#93;  ;; contains the old state and the new state.
  &amp;#40;let &amp;#91;hp &amp;#40;:hp new&amp;#41;&amp;#93;
      &amp;#40;if &amp;#40;= 0 hp&amp;#41;
    &amp;#40;println &amp;quot;You are now dead&amp;quot;&amp;#41;   ;; prints this if hp is equal to 0.
    &amp;#40;println &amp;quot;You are at&amp;quot; hp &amp;quot;health&amp;quot;&amp;#41;&amp;#41;&amp;#41;&amp;#41;   ;; prints this if not 0.
    
&amp;#40;add-watch player :health watch-health&amp;#41;  ;; watch-health is the function used to monitor the player health.    
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Now we can check if the atom is actually being watched.&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&amp;#40;player-damage 50&amp;#41; ;; now if you call this you'll see the hp being printed and than the second time it'll be zero and it'll drop into the negative healths.
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Now the atom being monitored and we are notified when the health is dropped to 0. This can have all kinds of implementations that require watching a value drop or increase to a specific value and than a certain action being applied in this cause we only printed but we could do anything from programming things like automatically turning on an air conditioner if the temperature is a certain amount in the room or can watch for a specific time and alert you to something u have to do at that time. There is a wide varity of things that can be done with watch and is an extremely important feature.&lt;/p&gt;
</description>
<enclosure>

</enclosure>
<pubDate>
Wed, 21 Sep 2016 00:00:00 -0400
</pubDate>
</item>
<item>
<guid>
http://blogawesome.com/posts-output/basics-of-clojurepart4/
</guid>
<link>
http://blogawesome.com/posts-output/basics-of-clojurepart4/
</link>
<title>
Basics of Clojure - Atoms (Part 4)
</title>
<description>
&lt;p&gt;This is like the fun part where you can now begin to model databases using atoms. Atoms are used a whole lot in clojure and are particularly useful so make sure you know them well. Here I'm just going to provide a brief outline of what atoms can do without explaining what atoms are actually which is a whole another conversation.&lt;/p&gt;&lt;p&gt;Let me introduce to you the atom data structure.&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&amp;#40;type &amp;#40;atom {}&amp;#41;&amp;#41; ;; This is an atom. 
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Also the persistant Array Map which is another data structure in clojure. Typically we don't use vectors when using atoms. &lt;/p&gt;&lt;pre&gt;&lt;code&gt;&amp;#40;type {}&amp;#41; ;; Using {} is a persistantArrayMap in other languages this can be thought of as hashes. 
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Now that you are familiar with the data structures that will be presented lets use atoms and persistantArrayMaps to create a var called stats that will contain two values which will be health points and gold. We can do this by the following...&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&amp;#40;def stats &amp;#40;atom {:hp 100 :gold 0}&amp;#41;&amp;#41; ;; How to create an atom in clojure. The :hp and :gold are key-words that can be used to look up the values later on.

&amp;#40;println @stats&amp;#41; ;; This shows the value of stats. Notice that you have to add the @ to show the value of stats. This is called dereferencing an atom.

&amp;#40;println &amp;#40;:hp @stats&amp;#41;&amp;#41; ;; This will show you the value for hp which is 100. key-words are useful to look up specific values.
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Now that you can somewhat view and make atoms how would you go about updating stats with a new value? We do this with swap!&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&amp;#40;swap! stats assoc :hp 13&amp;#41; ;; Now you have changed the hp value in stats

&amp;#40;println @stats&amp;#41; ;; You can check that the value of stats changed to 13
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Now what if you want to increase or decrease one of the values without changing to a specific number?&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&amp;#40;defn gold-inc &amp;#91;&amp;#93;
  &amp;#40;swap! stats update-in &amp;#91;:gold&amp;#93; + 1&amp;#41;&amp;#41; ;; using update-in will increase the gold value by 1 every time it is called.

&amp;#40;println @stats&amp;#41; ;; You can now see the the gold as increased by the number of times the previous swap! was called.  
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;You can also write the same gold-inc function using just a function in swap.&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&amp;#40;defn gold-inc &amp;#91;&amp;#93;
  &amp;#40;swap! stats update-in &amp;#91;:gold&amp;#93; inc&amp;#41;&amp;#41; ;; We replaced the + 1 with an existing clojure library function inc which increases the argument by 1.
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;What if we want a general function that will allow us to increase or decrease a specific value of stats we want. We can write a function called change-by.&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&amp;#40;defn change-by &amp;#91;key val&amp;#93;
  &amp;#40;swap! stats update-in &amp;#91;&amp;#40;keyword key&amp;#41;&amp;#93; + val&amp;#41;&amp;#41; ;; something new is the keyword function that converts a string into a keyword.
  
&amp;#40;change-by &amp;quot;gold&amp;quot; 4&amp;#41; ;; Increase the gold value by 4.  
  
&amp;#40;println @stats&amp;#41; ;; you can now check that your value has changed for gold.  

&amp;#40;change-by &amp;quot;hp&amp;quot; -5&amp;#41; ;; Decreases the hp value by 5.
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;One last thing to add is if you want to reset the entire atom. &lt;/p&gt;&lt;pre&gt;&lt;code&gt;&amp;#40;reset! stats {:hp 100 :gold 0}&amp;#41; ;; this will set the value of stats to {:hp 100 :gold 0} 
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Now you have everything you need to make your own little RPG text games!&lt;/p&gt;
</description>
<enclosure>

</enclosure>
<pubDate>
Tue, 20 Sep 2016 00:00:00 -0400
</pubDate>
</item>
<item>
<guid>
http://blogawesome.com/posts-output/basics-of-clojurepart3/
</guid>
<link>
http://blogawesome.com/posts-output/basics-of-clojurepart3/
</link>
<title>
Basics of Clojure - Recursion (Part 3)
</title>
<description>
  &lt;p&gt;If you're learning clojure chances are this isn't your first language. So you probably have some familiarity with what recursion is.&lt;/p&gt;&lt;p&gt;We will start off with making a simple factorial function to get us started with seeing recursion.&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&amp;#40;defn factorial &amp;#91;n&amp;#93;  ;; our factorial function accepting one argument
  &amp;#40;if &amp;#40;= n 1&amp;#41;        ;; checks if n is equal to 1 and if so returns 1
    1
    &amp;#40;&amp;#42; n &amp;#40;factorial &amp;#40;dec n&amp;#41;&amp;#41;&amp;#41;&amp;#41;&amp;#41;  ;; calls the factorial again after decreasing n by 1.
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Alright now lets see if it works by doing a test.&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&amp;#40;factorial 3&amp;#41; ;; which we know should be 3x2x1 which is 6. So it works.

;; 6
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;So lets test the power of our function by doing something larger like 40.&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&amp;#40;factorial 40&amp;#41; ;; Oh no a StackOverError. What happened?
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;So our function isn't as great as we may think. It won't accept larger numbers.&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&amp;#40;defn factorial &amp;#91;n&amp;#93; ;; Our factorial function accepts one argument.
  &amp;#40;loop &amp;#91;n n        ;; This is the looping part which sets our argument to n
         sum 1&amp;#93;     ;; Our sum is just one for now.
    &amp;#40;if &amp;#40;= n 0&amp;#41;     ;; If n becomes 0 than return the sum basically ends the loop
      sum
      &amp;#40;recur &amp;#40;dec n&amp;#41; &amp;#40;&amp;#42; sum n&amp;#41;&amp;#41;&amp;#41;&amp;#41;&amp;#41;  ;; This will continue the loop til the if state is met.
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Using recur will ensure that you won't run into a StackOverError such as the function before was not taking advantage of recur and thus was not head-tail optimized clojure will do tail-call optimization if you use the recur function. Also if use this function now it'll give you a StackOverError but because you have to set the JVM using -Xss and -XThreadStackSize to set the stack size otherwise you'll still get this error for numbers greater than 20. &lt;/p&gt;&lt;p&gt;There is an even shorter two line way of doing it using reduce as I showed you previously.&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&amp;#40;defn factorial &amp;#91;n&amp;#93;
  &amp;#40;reduce &amp;#42; &amp;#40;range 1 &amp;#40;inc n&amp;#41;&amp;#41;&amp;#41;&amp;#41; ;; Takes advantage of range making a list of numbers.
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The second one takes advantage of range since it creates a list of numbers and than reduce multiplies all the numbers that range creates.&lt;/p&gt;
</description>
<enclosure>

</enclosure>
<pubDate>
Sun, 18 Sep 2016 00:00:00 -0400
</pubDate>
</item>
<item>
<guid>
http://blogawesome.com/posts-output/basics-of-clojurepart2/
</guid>
<link>
http://blogawesome.com/posts-output/basics-of-clojurepart2/
</link>
<title>
Basics of Clojure - Mapping (Part 2)
</title>
<description>
&lt;p&gt;Link to Previous Guide: &lt;a href='https://defunsm.github.io/posts-output/basics-of-clojure/'&gt;Basics of Clojure (Part 1)&lt;/a&gt;&lt;/p&gt;&lt;p&gt;Today we'll explore how to do some mapping in clojure. &lt;/p&gt;&lt;p&gt;Lets start off with writing a simple function that will add one to whatever argument given.&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&amp;#40;defn add &amp;#91;x&amp;#93; &amp;#40;+ x 1&amp;#41;&amp;#41; ;; function that adds one to the argument given.
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Now lets make something called a vector which will contain numbers that we want to manipulate later on.&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&amp;#40;def numbers &amp;#91;1 2 3&amp;#93;&amp;#41; ;; this is how you create a persistant vector.

&amp;#40;type numbers&amp;#41; ;; shows you that the numbers is of type persistantvector.
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Now we can map the function add across the vector to each number using map like so.&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&amp;#40;map add numbers&amp;#41; ;; This will essentially add 1 to each number in the vector.

;; &amp;#40;2 3 4&amp;#41; 
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Notice how the end result is a LazySeq and not a vector. I'm not going to get into why that happens but you can do some research into the reason why.&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&amp;#40;type &amp;#40;map add numbers&amp;#41;&amp;#41; ;; This is of type LazySeq.

&amp;#40;vec &amp;#40;map add numbers&amp;#41;&amp;#41; ;; turns the LazySeq into a vector if it really bothers you.

&amp;#40;type &amp;#40;vec &amp;#40;map add numebrs&amp;#41;&amp;#41;&amp;#41; ;; Shows that the result from using vec on the lazyseq returns a vector.
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;You could also do it like the following to achieve the same result as previous.&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&amp;#40;map &amp;#40;fn &amp;#91;x&amp;#93; &amp;#40;+ x 1&amp;#41;&amp;#41; numbers&amp;#41; ;; this time you're just using an anonymous function. 
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Now lets say we want the second power of all numbers from 1 to 100? How would we go about such as task? Well lets start off with a function that raises an argument to the second power.&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&amp;#40;defn powertwo &amp;#91;x&amp;#93; &amp;#40;&amp;#42; x x&amp;#41;&amp;#41; ;; raises it to the second power since its multiplying by itself.

&amp;#40;powertwo 7&amp;#41; ;; should give you 49 to see that it works.
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Now we don't wanna write out 1 to 100 so we'll just create a lazyseq for it by the following using range.&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&amp;#40;range 101&amp;#41; ;; it gives us all the numbers 0 to 100. However we don't really want 0 so we can do the following.

&amp;#40;rest &amp;#40;range 101&amp;#41;&amp;#41; ;; this gives us a list so add vec to it.

&amp;#40;vec &amp;#40;rest &amp;#40;range 101&amp;#41;&amp;#41;&amp;#41; ;; there we go.

&amp;#40;def numbers &amp;#40;rest &amp;#40;range 101&amp;#41;&amp;#41;&amp;#41; ;; now we have that binded to numbers.
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Now we can use map to use our powertwo function over all then numbers.&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&amp;#40;map powertwo numbers&amp;#41; ;; now all the numbers are raised to the second power. 
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Thats about it and finally as a bonus I'll show you another function reduce. That will give you the sum of all the numbers in the vector!&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&amp;#40;reduce + &amp;#40;map powertwo numbers&amp;#41;&amp;#41; ;; BONUS
&lt;/code&gt;&lt;/pre&gt; 
</description>
<enclosure>

</enclosure>
<pubDate>
Sat, 17 Sep 2016 00:00:00 -0400
</pubDate>
</item>
<item>
<guid>
http://blogawesome.com/posts-output/basics-of-clojure/
</guid>
<link>
http://blogawesome.com/posts-output/basics-of-clojure/
</link>
<title>
Basics of Clojure (Part 1)
</title>
<description>
&lt;p&gt;Hello world is kind of the basic thing to start off with in any kind of programming language so we'll start with that. So open up your favorite text editor that has clojure preferably emacs or vim. Type out the following code. First start a nrepl in your text editor. Type the following into the repl.&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&amp;#40;println &amp;quot;Hello World&amp;quot;&amp;#41; ;; displays hello world in the repl.

;; &amp;quot;Hello World&amp;quot;
&lt;/code&gt;&lt;/pre&gt;Now that you have done the hello world lets look at addition, subtraction, multiplication, and division.&lt;pre&gt;&lt;code&gt;&amp;#40;+ 2 3&amp;#41; ;; same as doing 2 + 3

;; 5

&amp;#40;- 2 3&amp;#41; ;; same as doing 2 - 3

;; -1

&amp;#40;&amp;#42; 2 3&amp;#41; ;; same as doing 2 &amp;#42; 3

;; 6

&amp;#40;/ 2 3&amp;#41; ;; same as doing 2 / 3 notice that the result is displayed in a fraction try doing &amp;#40;float &amp;#40;/ 2 3&amp;#41;&amp;#41;.

;; 2/3

&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Notice that the operand is &lt;i&gt;after&lt;/i&gt; the operator. This is polish notation which is used in lisp dialects. This way doing 2 + 2 + 2 is easier since you won't have to repeat the + operator (+ 2 2 2). You can think of the applying the addition to all of the things in the parantheses. At first you might wonder whats the point of doing it like that instead of just doing (2 + 2) which will give you an error.&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&amp;#40;def five 5&amp;#41; ;; binds the symbol five to the number 5. Creating a global variable.

&amp;#40;+ 2 five&amp;#41; ;; same thing as doing &amp;#40;+ 2 5&amp;#41; since five is binded to 5.

;; 7
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Using def is how you can create variables and I'll show you now how to make functions.&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&amp;#40;&amp;#40;fn &amp;#91;x&amp;#93; &amp;#40;&amp;#42; x x&amp;#41;&amp;#41; 5&amp;#41; ;; as you can see the fn is how you start the function and than it takes one input the x and than does whatever is in the parantheses.

;; 25

&amp;#40;def square &amp;#40;fn &amp;#91;x&amp;#93; &amp;#40;&amp;#42; x x&amp;#41;&amp;#41;&amp;#41; ;; this is the same thing as before but now we are binding the function to the symbol square. So we can use it else where without typing the function again.

&amp;#40;square 5&amp;#41; ;; same result of 25.

;; 25

&amp;#40;defn square &amp;#91;x&amp;#93; &amp;#40;&amp;#42; x x&amp;#41;&amp;#41; ;; this creates the function and notice how we don't use fn anymore.

&amp;#40;square 5&amp;#41; ;; results are the same so now you have 3 different ways to produce the same result.

;; 25
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;A quick useful example of using functions is making a function that calculates the hypothenuse given both legs a and b.&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&amp;#40;defn find-hypothenuse &amp;#91;a b&amp;#93; &amp;#40;Math/sqrt &amp;#40;+ &amp;#40;&amp;#42; a a&amp;#41; &amp;#40;&amp;#42; b b&amp;#41;&amp;#41;&amp;#41;&amp;#41; ;; this is making our function basically using the pythagorean theorem a&amp;#94;2 + b&amp;#94;2 = c&amp;#94;2.

&amp;#40;find-hypothenuse 3 4&amp;#41; ;; if you know your pythagorean triples you know easily this is 5 which is what the result gives us.

;; 5.0  
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;That is about it for now as you can see you can make some useful things out of these functions and get them to work for you rather easily. Be careful when using def and defn since sometimes it is confusing to realize the subtle difference between them. &lt;/p&gt;
</description>
<enclosure>

</enclosure>
<pubDate>
Sun, 11 Sep 2016 00:00:00 -0400
</pubDate>
</item>
<item>
<guid>
http://blogawesome.com/posts-output/terminalshell/
</guid>
<link>
http://blogawesome.com/posts-output/terminalshell/
</link>
<title>
Terminals and Shell Commands
</title>
<description>
&lt;p&gt;&lt;h2&gt;What is a Terminal?&lt;/h2&gt; You might have seen these in those hacker movies. The terminal allows the user to gain access to the computer. However there is much more than just that.&lt;br /&gt;&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://defunsm.github.io/img/terminals.png&quot; alt=&quot;Terminal&quot; /&gt;&lt;/p&gt;&lt;p&gt;&lt;h2&gt;What is a TTY? Are they the same?&lt;/h2&gt; Often they are said interchangably and they do essentially the same thing. However a key characteristic is that a TTY is provided by the system and the terminal is run on a TTY. While there is no real difference between them unless further examination. &lt;/p&gt;&lt;p&gt;&lt;h2&gt;How do I open a Terminal?&lt;/h2&gt;&lt;/p&gt;&lt;p&gt;On windows you can do this by pressing 'windows key' (windows logo) + 'X'.&lt;br /&gt;&lt;/p&gt;&lt;p&gt;&lt;h2&gt;Commands on the Terminal&lt;/h2&gt;&lt;/p&gt;&lt;p&gt;&lt;code&gt;dir &lt;/code&gt;&amp;nbsp; - list (dir)ectories.&lt;/p&gt;&lt;p&gt;&lt;code&gt;cd &lt;/code&gt;&amp;nbsp; - (c)hange (d)irectory - Changes to a different folder or directory.&lt;/p&gt;&lt;p&gt;&lt;code&gt;mkdir &lt;/code&gt;&amp;nbsp; - (m)a(k)e (dir)ectory - Creates a new folder or directory.&lt;/p&gt;&lt;p&gt;&lt;code&gt;rm &lt;/code&gt;&amp;nbsp; - (r)e(m)oves a file.&lt;/p&gt;&lt;p&gt;&lt;code&gt;mv &lt;/code&gt;&amp;nbsp; - (m)o(v)e a file or can be used to rename a file.&lt;/p&gt;&lt;p&gt;&lt;code&gt;cp &lt;/code&gt;&amp;nbsp; - (c)o(p)y a file to another location.&lt;/p&gt;&lt;p&gt;&lt;code&gt;grep &lt;/code&gt;&amp;nbsp; - prints lines that match the pattern.&lt;/p&gt;&lt;p&gt;&lt;code&gt;touch &lt;/code&gt;&amp;nbsp; - creates a file.&lt;/p&gt;&lt;p&gt;&lt;code&gt;cat &lt;/code&gt;&amp;nbsp; - prints out the contents of a file.&lt;/p&gt;&lt;p&gt;&lt;code&gt;echo &lt;/code&gt;&amp;nbsp; - prints the string.&lt;/p&gt;&lt;p&gt;&lt;code&gt; &gt;&gt; &lt;/code&gt;&amp;nbsp; - appending output without removing previous text in a file.&lt;/p&gt;&lt;p&gt;&lt;code&gt; &gt; &lt;/code&gt;&amp;nbsp; - rewriting the output to a file.&lt;/p&gt;&lt;p&gt;&lt;code&gt; | &lt;/code&gt;&amp;nbsp; - pipes the output.&lt;/p&gt;&lt;p&gt;&lt;code&gt;shutdown &lt;/code&gt;&amp;nbsp; - causes the computer to shutdown.&lt;/p&gt;&lt;p&gt;&lt;code&gt;reboot &lt;/code&gt;&amp;nbsp; - causes the computer to reboot.&lt;/p&gt;&lt;p&gt;&lt;code&gt;man &lt;/code&gt;&amp;nbsp; - searches for the documentation of a certain command.&lt;/p&gt;&lt;p&gt;&lt;code&gt;whatis &lt;/code&gt;&amp;nbsp; - provides a one line description of the command.&lt;/p&gt;&lt;p&gt;&lt;code&gt;whoami &lt;/code&gt;&amp;nbsp; - returns the user.&lt;/p&gt;&lt;p&gt;&lt;code&gt;find &lt;/code&gt;&amp;nbsp; - searches for a file.&lt;/p&gt;&lt;p&gt;&amp;nbsp;&lt;/p&gt;&lt;p&gt;Usage of Commands:&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Changing/Making/Removing a File&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;code&gt;touch text.txt &lt;/code&gt; - creates a file called 'text.txt'.&lt;/p&gt;&lt;p&gt;&lt;code&gt;echo &quot;some text&quot; &gt;&gt; text.txt &lt;/code&gt; - writes 'some text' into a file called 'text.txt'.&lt;/p&gt;&lt;p&gt;&lt;code&gt;echo &quot;some other text&quot; &gt; text.txt &lt;/code&gt; - rewrites 'some other text' into a file called 'text.txt'.&lt;/p&gt;&lt;p&gt;&lt;code&gt;echo &quot;&quot; &gt; text.txt &lt;/code&gt; - easy trick to truncate a file without removing it. &lt;/p&gt;&lt;p&gt;&lt;strong&gt;Changing/Making/Removing Directories&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;code&gt;mkdir somedirectory &lt;/code&gt; - creates a directory called 'somedirectory'.&lt;/p&gt;&lt;p&gt;&lt;code&gt;rmdir somedirectory &lt;/code&gt; - removes a directory called 'somedirectory'.&lt;/p&gt;&lt;p&gt;&lt;code&gt;rmdir -r somedirectory &lt;/code&gt; - removes a directory and all of the contents in 'somedirectory'.&lt;/p&gt;&lt;p&gt;&lt;code&gt;cd ~ &lt;/code&gt; - changes to the home directory.&lt;/p&gt;&lt;p&gt;&lt;code&gt;cd / &lt;/code&gt; - changes to the root directory.&lt;/p&gt;&lt;p&gt;&lt;code&gt;cd .. &lt;/code&gt; - moves down a directory.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Miscellaneous&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;code&gt;man man&lt;/code&gt; - provides information on the man command itself.&lt;br /&gt;&lt;/p&gt;&lt;p&gt;&lt;code&gt;ls | grep &quot;word&quot; &lt;/code&gt; - this will highlight any directory that contains the pattern &quot;word&quot;.&lt;/p&gt;&lt;p&gt;&lt;code&gt;find -name &quot;*.pdf&quot; &lt;/code&gt; - searches for all pdf files.&lt;/p&gt;&lt;p&gt;&lt;code&gt;cat text.txt &lt;/code&gt; - quick way to display the contents of a text file in this case will display the contents of text.txt.&lt;/p&gt;&lt;p&gt;&lt;code&gt;pwd &lt;/code&gt; - displays the current directory that you are in.&lt;/p&gt;&lt;p&gt;&lt;code&gt;cp file.txt /home/file.txt &lt;/code&gt; - copies the file to the home directory saved as file.txt.&lt;/p&gt;&lt;p&gt;&lt;code&gt;cp /home/* /etc &lt;/code&gt; - copies all the home files to /etc directory.&lt;/p&gt;&lt;p&gt;Sources: &lt;a href=&quot;http://askubuntu.com/questions/14284/why-is-a-virtual-terminal-virtual-and-what-why-where-is-the-real-terminal/14294#14294&quot; target=&quot;&lt;i&gt;blank&quot;&gt;Terminals&lt;/a&gt;, &lt;a href=&quot;http://www.linusakesson.net/programming/tty/index.php&quot; target=&quot;&lt;/i&gt;blank&quot;&gt;TTY&lt;/a&gt;&lt;/p&gt;
</description>
<enclosure>

</enclosure>
<pubDate>
Thu, 08 Sep 2016 00:00:00 -0400
</pubDate>
</item>
<item>
<guid>
http://blogawesome.com/posts-output/path-finding/
</guid>
<link>
http://blogawesome.com/posts-output/path-finding/
</link>
<title>
Pathfinding
</title>
<description>
&lt;p&gt;&lt;img src=&quot;https://defunsm.github.io/img/pathfinding.gif&quot; alt=&quot;light&quot; /&gt;&lt;/p&gt;&lt;p&gt;You may have been told that light takes the fastest path. Or if you ever used a GPS (Global Positioning System) and magically a path is shown usually the shortest path unless theres traffic than the shortest time is shown. But how? Do protons somehow perform mathmatical calculations in their head to determine which path they should take? &lt;/p&gt;&lt;p&gt;Nope, light actually takes all paths and then due to wave interface only the fastest path is &quot;shown&quot;. Of course thats much more simply said and much more than that happens and if really want to know how light takes the &quot;fastest&quot; path you can read Richard P. Feynman's book &lt;i&gt;'The Strange Theory of Light and Matter'&lt;/i&gt;. He explains the topic rather well in a way that you don't need to be a physic's major to understand. &lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://defunsm.github.io/img/pathfinding2.gif&quot; alt=&quot;time dialation&quot; /&gt;&lt;/p&gt;&lt;p&gt;As for a GPS, satellites are calibrated percisely because  we know of special relativity in 1905 from Einstein that time for moving objects are slower than objects that are stationary thus with the help of relativity to account for this small change in time we can figure out the position of a person using a gps from the time the signal takes to reach that person. Even a slight error would make the position off by a good amount. Not only that but than the gps calculates the shortest or fastest path to get to your destination using an algorithm. &lt;/p&gt;&lt;p&gt;Algorithms can be used for things from data processing, response automation, optimization and pathfinding is just one thing that can be done by implmenting such a thing. The A* algorithm is a common one implemented in games. There are all kinds of algorithms for pathfinding some are better and some are worse, and than there are some that are more extensive and some that are less extensive to use. If you take computer science you'll probably be familiar with the quicksort, bubblesort and later on probably the greedy and divide and conquer algorithm. Point is there is a lot of them. &lt;/p&gt; 
</description>
<enclosure>

</enclosure>
<pubDate>
Wed, 07 Sep 2016 00:00:00 -0400
</pubDate>
</item>
<item>
<guid>
http://blogawesome.com/posts-output/2016-09-03-using_quil_part_2/
</guid>
<link>
http://blogawesome.com/posts-output/2016-09-03-using_quil_part_2/
</link>
<title>
Graphics using Quil in Clojure (Part 2)
</title>
<description>
 &lt;p&gt;If you are interested in following along please read the &lt;a href='https://defunsm.github.io/posts-output/using_quil/'&gt;first part&lt;/a&gt; or it may not make sense. &lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://defunsm.github.io/img/quilthird.png&quot; alt=&quot;quil line segments&quot; /&gt;&lt;/p&gt;&lt;p&gt;We are going to continue with the same project as we did in part 1 with newquil-project. However we are going to rewrite the draw function. First we need some defs to be added in the beginning so add the following in the top after the name space.&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&amp;#40;def mouse-press-time &amp;#40;atom 0&amp;#41;&amp;#41;     ;; The original time for when them mouse was clicked.
&amp;#40;def mouse-hold-x &amp;#40;atom 0&amp;#41;&amp;#41;         ;; The x-location when the mouse was clicked.
&amp;#40;def mouse-hold-y &amp;#40;atom 0&amp;#41;&amp;#41;         ;; The y-location when the mouse was clicked.
&amp;#40;def mouse-release-stage &amp;#40;atom 0&amp;#41;&amp;#41;  ;; The release stage &amp;#40;0 - nothing, 1 - pressed&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Those will come in handy while setting up our draw function which we'll completely rewrite. Change the stroke/stroke-weight/fill to the following values.&lt;/p&gt;&lt;pre&gt;&lt;code&gt;  &amp;#40;q/stroke 100&amp;#41;          ;; Change to 100 rather than q/random
  &amp;#40;q/stroke-weight 5&amp;#41;     ;; Change to 5
  &amp;#40;q/fill 100&amp;#41;            ;; Change to 100
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Now you can remove everything else in the draw function. Adding the following into the draw function after the stroke/stroke-weight/fill.&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&amp;#40;if &amp;#40;q/mouse-pressed?&amp;#41; ;; When the mouse is pressed it returns true.
    &amp;#40;do &amp;#40;if &amp;#40;= 0 @mouse-release-stage&amp;#41;      ;; This can only happen when mouse-release-stage is 0 so that the values aren't reset every time it's held.
          &amp;#40;do &amp;#40;let &amp;#91;diam 10&amp;#93;                 
                &amp;#40;q/ellipse &amp;#40;q/mouse-x&amp;#41; &amp;#40;q/mouse-y&amp;#41; diam diam&amp;#41;&amp;#41;  ;; Creates a circle of 10 diam.
              &amp;#40;reset! mouse-press-time &amp;#40;q/millis&amp;#41;&amp;#41; ;; Sets the press time to the current time in milliseconds.
              &amp;#40;reset! mouse-hold-x &amp;#40;q/mouse-x&amp;#41;&amp;#41;    ;; Sets the mouse-hold-x time to where the mouse is on the x coordinate.
              &amp;#40;reset! mouse-hold-y &amp;#40;q/mouse-y&amp;#41;&amp;#41;    ;; Same for the y coordinate.
              &amp;#40;reset! mouse-release-stage 1&amp;#41;&amp;#41;&amp;#41;&amp;#41;    ;; Sets the mouse-release-stage to 1 so that the release can trigger only once. 
    &amp;#40;do &amp;#40;if &amp;#40;= 1 @mouse-release-stage&amp;#41;             ;; Only occurs if the mouse-release stage is 1.
          &amp;#40;do &amp;#40;reset! mouse-release-stage 0&amp;#41;                     
              &amp;#40;let &amp;#91;delta-time &amp;#40;- &amp;#40;q/millis&amp;#41; @mouse-press-time&amp;#41; ;; The time change between the click and release.
                    mouse-release-x &amp;#40;q/mouse-x&amp;#41;     ;; Release x coordinate.
                    mouse-release-y &amp;#40;q/mouse-y&amp;#41;     ;; Release y coordinate.
                    delta-x &amp;#40;- mouse-release-x @mouse-hold-x&amp;#41;  ;; Change in x coordinate.
                    delta-y &amp;#40;- mouse-release-y @mouse-hold-y&amp;#41;  ;; Change in y coordinate.
                    distance &amp;#40;Math/sqrt &amp;#40;+ &amp;#40;&amp;#42; delta-x delta-x&amp;#41; &amp;#40;&amp;#42; delta-y delta-y&amp;#41;&amp;#41;&amp;#41; ;; Finds the distance between two points.
                    vel &amp;#40;/ distance delta-time&amp;#41;&amp;#93; ;; Calculates the avg velocity by taking the distance and time changed.
                &amp;#40;let &amp;#91;diam 10&amp;#93;
                  &amp;#40;q/ellipse &amp;#40;q/mouse-x&amp;#41; &amp;#40;q/mouse-y&amp;#41; diam diam&amp;#41;&amp;#41; ; creates another circle at the end point of release.
                &amp;#40;q/stroke 255 0 0&amp;#41;  
                &amp;#40;q/stroke-weight 2&amp;#41;
                &amp;#40;q/line @mouse-hold-x @mouse-hold-y mouse-release-x mouse-release-y&amp;#41; ;; Creates a line from the first to end circle.
                &amp;#40;println &amp;quot;Dt: &amp;quot; delta-time &amp;quot;Dx: &amp;quot; delta-x &amp;quot;Dy: &amp;quot; delta-y &amp;quot;X: &amp;quot; distance &amp;quot;V: &amp;quot; vel&amp;#41;&amp;#41;&amp;#41;&amp;#41;&amp;#41;&amp;#41; ;; Prints out all the information.

&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Now you can run it by the following...&lt;/p&gt;&lt;pre&gt;&lt;code&gt;lein run
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Now you can click on the applet and release in a different place and should see lines connecting two circles! As a bonus if you want to clear the applet without exiting you can add the following in the draw function...&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&amp;#40;if &amp;#40;q/key-pressed?&amp;#41;
  &amp;#40;do &amp;#40;if &amp;#40;= &amp;#40;.toString &amp;#40;q/raw-key&amp;#41;&amp;#41; &amp;quot;c&amp;quot;&amp;#41;
          &amp;#40;do &amp;#40;q/clear&amp;#41;
              &amp;#40;q/background 200&amp;#41;&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;So this is what your entire core.clj should look like. More or less with some extra key presses.&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&amp;#40;ns newquil-project.core
  &amp;#40;:require &amp;#91;quil.core :as q&amp;#93;
            &amp;#91;quil.middleware :as m&amp;#93;&amp;#41;&amp;#41;

&amp;#40;def brush &amp;#40;atom 0&amp;#41;&amp;#41; ;; if the brush is up or down &amp;#40;0 - down 1 - up&amp;#41;
&amp;#40;def mouse-press-time &amp;#40;atom 0&amp;#41;&amp;#41; ;; The original time for the mouse press
&amp;#40;def mouse-hold-x &amp;#40;atom 0&amp;#41;&amp;#41;
&amp;#40;def mouse-hold-y &amp;#40;atom 0&amp;#41;&amp;#41;
&amp;#40;def mouse-release-stage &amp;#40;atom 0&amp;#41;&amp;#41;

&amp;#40;defn setup &amp;#91;&amp;#93;
  &amp;#40;q/frame-rate 20&amp;#41;
  &amp;#40;q/background 200&amp;#41;&amp;#41;

&amp;#40;defn draw &amp;#91;&amp;#93;
  &amp;#40;q/stroke 100&amp;#41;
  &amp;#40;q/stroke-weight 5&amp;#41;
  &amp;#40;q/fill 100&amp;#41;

  &amp;#40;if &amp;#40;= 1 @brush&amp;#41;
    &amp;#40;let &amp;#91;diam &amp;#40;q/random 100&amp;#41;&amp;#93;
      &amp;#40;q/ellipse &amp;#40;q/mouse-x&amp;#41; &amp;#40;q/mouse-y&amp;#41; diam diam&amp;#41;&amp;#41;&amp;#41;

  &amp;#40;if &amp;#40;q/mouse-pressed?&amp;#41;
    &amp;#40;do &amp;#40;if &amp;#40;= 0 @mouse-release-stage&amp;#41;
          &amp;#40;do &amp;#40;let &amp;#91;diam 10&amp;#93;
                &amp;#40;q/ellipse &amp;#40;q/mouse-x&amp;#41; &amp;#40;q/mouse-y&amp;#41; diam diam&amp;#41;&amp;#41;
              &amp;#40;reset! mouse-press-time &amp;#40;q/millis&amp;#41;&amp;#41;
              &amp;#40;reset! mouse-hold-x &amp;#40;q/mouse-x&amp;#41;&amp;#41;
              &amp;#40;reset! mouse-hold-y &amp;#40;q/mouse-y&amp;#41;&amp;#41;
              &amp;#40;reset! mouse-release-stage 1&amp;#41;&amp;#41;&amp;#41;&amp;#41;
    &amp;#40;do &amp;#40;if &amp;#40;= 1 @mouse-release-stage&amp;#41;
          &amp;#40;do &amp;#40;reset! mouse-release-stage 0&amp;#41;
              &amp;#40;let &amp;#91;delta-time &amp;#40;- &amp;#40;q/millis&amp;#41; @mouse-press-time&amp;#41;
                    mouse-release-x &amp;#40;q/mouse-x&amp;#41;
                    mouse-release-y &amp;#40;q/mouse-y&amp;#41;
                    delta-x &amp;#40;- mouse-release-x @mouse-hold-x&amp;#41;
                    delta-y &amp;#40;- mouse-release-y @mouse-hold-y&amp;#41;
                    distance &amp;#40;Math/sqrt &amp;#40;+ &amp;#40;&amp;#42; delta-x delta-x&amp;#41; &amp;#40;&amp;#42; delta-y delta-y&amp;#41;&amp;#41;&amp;#41;
                    vel &amp;#40;/ distance delta-time&amp;#41;&amp;#93;
                &amp;#40;let &amp;#91;diam 10&amp;#93;
                  &amp;#40;q/ellipse &amp;#40;q/mouse-x&amp;#41; &amp;#40;q/mouse-y&amp;#41; diam diam&amp;#41;&amp;#41;
                &amp;#40;q/stroke 255 0 0&amp;#41;
                &amp;#40;q/stroke-weight 2&amp;#41;
                &amp;#40;q/line @mouse-hold-x @mouse-hold-y mouse-release-x mouse-release-y&amp;#41;
                &amp;#40;println &amp;quot;Dt: &amp;quot; delta-time &amp;quot;Dx: &amp;quot; delta-x &amp;quot;Dy: &amp;quot; delta-y &amp;quot;X: &amp;quot; distance &amp;quot;V: &amp;quot; vel&amp;#41;&amp;#41;&amp;#41;&amp;#41;&amp;#41;&amp;#41;

  &amp;#40;if &amp;#40;q/key-pressed?&amp;#41;
    &amp;#40;do &amp;#40;if &amp;#40;= &amp;#40;.toString &amp;#40;q/raw-key&amp;#41;&amp;#41; &amp;quot;q&amp;quot;&amp;#41;
          &amp;#40;do &amp;#40;q/exit&amp;#41;&amp;#41;&amp;#41;
        &amp;#40;if &amp;#40;= &amp;#40;.toString &amp;#40;q/raw-key&amp;#41;&amp;#41; &amp;quot;u&amp;quot;&amp;#41;
          &amp;#40;do &amp;#40;if &amp;#40;= 0 @brush&amp;#41;
                &amp;#40;reset! brush 1&amp;#41;
                &amp;#40;reset! brush 0&amp;#41;&amp;#41;&amp;#41;&amp;#41;
        &amp;#40;if &amp;#40;= &amp;#40;.toString &amp;#40;q/raw-key&amp;#41;&amp;#41; &amp;quot;e&amp;quot;&amp;#41;
          &amp;#40;do &amp;#40;let &amp;#91;radius &amp;#40;q/random 75&amp;#41;&amp;#93;
                &amp;#40;q/box radius radius radius&amp;#41;&amp;#41;&amp;#41;&amp;#41;
        &amp;#40;if &amp;#40;= &amp;#40;.toString &amp;#40;q/raw-key&amp;#41;&amp;#41; &amp;quot;c&amp;quot;&amp;#41;
          &amp;#40;do &amp;#40;q/clear&amp;#41;
              &amp;#40;q/background 200&amp;#41;&amp;#41;&amp;#41;&amp;#41;&amp;#41;&amp;#41;

&amp;#40;q/defsketch example
  :title &amp;quot;Oh so many grey circles&amp;quot;
  :settings #&amp;#40;q/smooth 2&amp;#41;
  :setup setup
  :draw draw
  :size &amp;#91;640 480&amp;#93;&amp;#41;

&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;And there you have it you can make line segments! And do all kinds of things if you add onto them.&lt;/p&gt;
</description>
<enclosure>

</enclosure>
<pubDate>
Sat, 03 Sep 2016 00:00:00 -0400
</pubDate>
</item>
<item>
<guid>
http://blogawesome.com/posts-output/getting-started-with-clojure/
</guid>
<link>
http://blogawesome.com/posts-output/getting-started-with-clojure/
</link>
<title>
Getting Started with Clojure
</title>
<description>
 &lt;p&gt; Since my guides are related to Clojure. I might as well write a guide of what my clojure setup looks like and also what resources I read to write clojure code.  &lt;/p&gt;&lt;p&gt; &lt;img src=&quot;https://defunsm.github.io/img/started.png&quot; alt=&quot;started&quot; /&gt;  &lt;/p&gt;&lt;p&gt; &lt;a href='https://www.gnu.org/software/emacs/'&gt;Emacs&lt;/a&gt;. I don't think there is more flexability when it comes it. You can also try GitHub's &lt;a href='https://atom.io/'&gt;Atom&lt;/a&gt; Text Editor.  &lt;/p&gt;&lt;p&gt; &lt;img src=&quot;https://defunsm.github.io/img/meme.jpg&quot; alt=&quot;clojure memes&quot; /&gt;  &lt;/p&gt;&lt;p&gt; For Atom you may need to download a few plugins before working with clojure code. Like Downloading the proto-nrepl. Paraindent and etc.  &lt;/p&gt;&lt;p&gt;After having emacs go ahead and get the &lt;a href='https://github.com/overtone/emacs-live'&gt;emacs live&lt;/a&gt; one which is absolutely almost necessary to write in any lisp dialect. &lt;/p&gt;&lt;p&gt;Emacs live might be a little tricky to install but they have an easy install on their repo and typing the following should install emacs live in just one line.&lt;/p&gt;&lt;pre&gt;&lt;code&gt;bash &amp;lt;&amp;#40;curl -fksSL https://raw.github.com/overtone/emacs-live/master/installer/install-emacs-live.sh&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;If you truely want to you can see my personal additions to emacs &lt;a href='https://github.com/defunSM/emacs-live'&gt;here&lt;/a&gt;.&lt;/p&gt;&lt;p&gt;Useful resources:&lt;/p&gt;&lt;ol&gt;&lt;li&gt;&lt;a href='http://www.braveclojure.com/'&gt;Braveclojure&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href='https://github.com/functional-koans/clojure-koans'&gt;Clojure Koans&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href='https://www.amazon.com/Joy-Clojure-Thinking-Way/dp/1935182641/ref=sr_1_2?ie=UTF8&amp;qid=1472942680&amp;sr=8-2&amp;keywords=joy+of+clojure'&gt;The joy of Clojure&lt;/a&gt; (This one is rather advanced.)&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;Things to look up as you are learning clojure:&lt;/p&gt;&lt;ol&gt;&lt;li&gt;&lt;a href='https://github.com/reagent-project/reagent'&gt;Reagent&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href='https://github.com/daveray/seesaw'&gt;Seesaw&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href='https://github.com/clojure/clojurescript'&gt;ClojureScript&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href='http://quil.info/'&gt;Quil&lt;/a&gt;&lt;/li&gt;&lt;/ol&gt;
</description>
<enclosure>

</enclosure>
<pubDate>
Fri, 02 Sep 2016 00:00:00 -0400
</pubDate>
</item>
<item>
<guid>
http://blogawesome.com/posts-output/using_quil/
</guid>
<link>
http://blogawesome.com/posts-output/using_quil/
</link>
<title>
Graphics using Quil in Clojure (Part 1)
</title>
<description>
 &lt;p&gt; I stumbled upon &lt;a href='http://quil.info/'&gt;quil&lt;/a&gt; which can be used to generate rather interesting graphics.&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://defunsm.github.io/img/quilsecond.png&quot; alt=&quot;quil&quot; /&gt;  &lt;/p&gt;&lt;p&gt;The way you start a quil project is the following...&lt;/p&gt;&lt;pre&gt;&lt;code&gt;lein new quil newquil-project
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Once you have done that you should have the project and you can cd to it.&lt;/p&gt;&lt;pre&gt;&lt;code&gt;cd newquil-project
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;If you check the project.clj you should see that quil is added as a dependency. Add the main function in the defproject to the following. So your project.clj should now look like this.&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&amp;#40;defproject newquil-project &amp;quot;0.1.0-SNAPSHOT&amp;quot;
  :description &amp;quot;FIXME: write description&amp;quot;
  :url &amp;quot;http://example.com/FIXME&amp;quot;
  :license {:name &amp;quot;Eclipse Public License&amp;quot;
            :url &amp;quot;http://www.eclipse.org/legal/epl-v10.html&amp;quot;}
  :dependencies &amp;#91;&amp;#91;org.clojure/clojure &amp;quot;1.8.0&amp;quot;&amp;#93;
                 &amp;#91;quil &amp;quot;2.4.0&amp;quot;&amp;#93;&amp;#93;
  :main newquil-project.core&amp;#41; ;; add this
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Now you can view what you are starting with by running...&lt;/p&gt;&lt;pre&gt;&lt;code&gt;lein run
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;You should see a circle changing colors as its orbiting the center of the applet. Now close the applet and clear the entire thing and lets work with a cool example from the quil github repo. So remove everything but the name space and add the following so your core.clj should look like this.&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&amp;#40;defn setup &amp;#91;&amp;#93;
  &amp;#40;q/frame-rate 1&amp;#41;                    ;; Set framerate to 1 FPS &amp;#40;I would set this to 20&amp;#41;
  &amp;#40;q/background 200&amp;#41;&amp;#41;                 ;; Set the background colour to
                                      ;; a nice shade of grey.
&amp;#40;defn draw &amp;#91;&amp;#93;
  &amp;#40;q/stroke &amp;#40;q/random 255&amp;#41;&amp;#41;             ;; Set the stroke colour to a random grey
  &amp;#40;q/stroke-weight &amp;#40;q/random 10&amp;#41;&amp;#41;       ;; Set the stroke thickness randomly
  &amp;#40;q/fill &amp;#40;q/random 255&amp;#41;&amp;#41;               ;; Set the fill colour to a random grey

  &amp;#40;let &amp;#91;diam &amp;#40;q/random 100&amp;#41;             ;; Set the diameter to a value between 0 and 100
        x    &amp;#40;q/random &amp;#40;q/width&amp;#41;&amp;#41;       ;; Set the x coord randomly within the sketch
        y    &amp;#40;q/random &amp;#40;q/height&amp;#41;&amp;#41;&amp;#93;     ;; Set the y coord randomly within the sketch
    &amp;#40;q/ellipse x y diam diam&amp;#41;&amp;#41;&amp;#41;         ;; Draw a circle at x y with the correct diameter

&amp;#40;q/defsketch example                  ;; Define a new sketch named example
  :title &amp;quot;Oh so many grey circles&amp;quot;    ;; Set the title of the sketch
  :settings #&amp;#40;q/smooth 2&amp;#41;             ;; Turn on anti-aliasing
  :setup setup                        ;; Specify the setup fn
  :draw draw                          ;; Specify the draw fn
  :size &amp;#91;323 200&amp;#93;&amp;#41;                    ;; You struggle to beat the golden ratio &amp;#40;640 by 480&amp;#41;
&lt;/code&gt;&lt;/pre&gt;Now I dont really prefer the golden ratio so I like changing the size to 640 to 480. As well as changing the frame rate to 20. So the circles pop up faster. Now you can run it and see the grey circles popup in the applet. Thats pretty neat. However what If I wanted to control when these circles by clicking on the applet? We could do that rather easily. Just add a condition in the draw function such as the following...&lt;pre&gt;&lt;code&gt;&amp;#40;defn draw &amp;#91;&amp;#93;
  &amp;#40;q/stroke &amp;#40;q/random 255&amp;#41;&amp;#41;             ;; Set the stroke colour to a random grey
  &amp;#40;q/stroke-weight &amp;#40;q/random 10&amp;#41;&amp;#41;       ;; Set the stroke thickness randomly
  &amp;#40;q/fill &amp;#40;q/random 255&amp;#41;&amp;#41;               ;; Set the fill colour to a random grey

  &amp;#40;if &amp;#40;q/mouse-pressed?&amp;#41;                    ;; add this condition.
    &amp;#40;do &amp;#40;let &amp;#91;diam &amp;#40;q/random 100&amp;#41;             ;; Set the diameter to a value between 0 and 100
              x    &amp;#40;q/random &amp;#40;q/width&amp;#41;&amp;#41;       ;; Set the x coord randomly within the sketch
              y    &amp;#40;q/random &amp;#40;q/height&amp;#41;&amp;#41;&amp;#93;     ;; Set the y coord randomly within the sketch
          &amp;#40;q/ellipse x y diam diam&amp;#41;&amp;#41;&amp;#41;&amp;#41;&amp;#41;&amp;#41; ;; Draw a circle at x y with the correct diameter
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;But why stop there what if you want circles to pop up at where you click on the applet? Using (q/mouse-x) and (q/mouse-y) you can easily do this by changing draw to this.&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&amp;#40;defn draw &amp;#91;&amp;#93;
  &amp;#40;q/stroke &amp;#40;q/random 255&amp;#41;&amp;#41;             ;; Set the stroke colour to a random grey
  &amp;#40;q/stroke-weight &amp;#40;q/random 10&amp;#41;&amp;#41;       ;; Set the stroke thickness randomly
  &amp;#40;q/fill &amp;#40;q/random 255&amp;#41;&amp;#41;               ;; Set the fill colour to a random grey

  &amp;#40;if &amp;#40;q/mouse-pressed?&amp;#41;                    ;; add this condition.
    &amp;#40;do &amp;#40;let &amp;#91;diam &amp;#40;q/random 100&amp;#41;&amp;#93;
          &amp;#40;q/ellipse &amp;#40;q/mouse-x&amp;#41; &amp;#40;q/mouse-y&amp;#41; diam diam&amp;#41;&amp;#41;&amp;#41;&amp;#41;&amp;#41; ;; Draw a circle at x y with the correct diameter
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Now that you have a cool drawing tool that makes circles!&lt;/p&gt; 
</description>
<enclosure>

</enclosure>
<pubDate>
Thu, 01 Sep 2016 00:00:00 -0400
</pubDate>
</item>
<item>
<guid>
http://blogawesome.com/posts-output/2016-08-31-Using_Swing_Part_2/
</guid>
<link>
http://blogawesome.com/posts-output/2016-08-31-Using_Swing_Part_2/
</link>
<title>
Creating JFrames using Swing APIs in Clojure (Part 2)
</title>
<description>
 &lt;p&gt;Ok so continuing on with what we have so far. If you havent read the &lt;a href='https://defunsm.github.io/posts-output/2016-08-30-Using_Swing/'&gt;first part&lt;/a&gt; I suggest reading it to follow through.&lt;/p&gt;&lt;p&gt;I want to show you a quick way to add more flavor to your frame since it looks rather dull. One way to do this is by adding substance to your dependencies which is basically like a bunch of themes for your frames.&lt;/p&gt;&lt;p&gt;Add the following to your dependencies in your project.clj&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&amp;#91;com.github.insubstantial/substance &amp;quot;7.1&amp;quot;&amp;#93;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Now you can import substance by changing your namespace to the following.&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&amp;#40;ns hello-swing.core
  &amp;#40;:import org.pushingpixels.substance.api.SubstanceLookAndFeel&amp;#41; ;; add this
  &amp;#40;:gen-class&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Now that you can use the substance themes you can set a default theme by adding to your -main.&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&amp;#40;defn -main &amp;#91;&amp;#93;
  &amp;#40;native!&amp;#41;
  &amp;#40;invoke-later
   &amp;#40;-&amp;gt; jframe show!&amp;#41;
   &amp;#40;SubstanceLookAndFeel/setSkin &amp;quot;org.pushingpixels.substance.api.skin.GraphiteAquaSkin&amp;quot;&amp;#41;&amp;#41;&amp;#41; ;; add this
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Now that you have set the theme automatically you can run what you have so far.&lt;/p&gt;&lt;pre&gt;&lt;code&gt;$ lein run
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;A frame like this should appear now and as you notice it has been decorated.&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://defunsm.github.io/img/jframesecond.png&quot; alt=&quot;jframe 2&quot; /&gt;&lt;/p&gt;&lt;p&gt;However you may now notice that there is a problem when opening the menubar and it just disappears. To fix this add pack! to your -main.&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&amp;#40;defn -main &amp;#91;&amp;#93;
  &amp;#40;native!&amp;#41;
  &amp;#40;invoke-later
   &amp;#40;-&amp;gt; jframe pack! show!&amp;#41; ;; add pack! Which should fix the menubar problem.
   &amp;#40;SubstanceLookAndFeel/setSkin &amp;quot;org.pushingpixels.substance.api.skin.GraphiteAquaSkin&amp;quot;&amp;#41;&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Now what if we want to select what theme we want? Now we can use the menubar to select what theme we want. In order to do this make a menubar item called theme-selector.&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&amp;#40;def jframe &amp;#40;frame :title &amp;quot;hello Frame&amp;quot;
                   :menubar &amp;#40;menubar :items &amp;#91;&amp;#40;menu :text &amp;quot;File&amp;quot; :items &amp;#91;close-frame theme-selector&amp;#93;&amp;#41;&amp;#93;&amp;#41; ;; add theme selector
                   :height 300
                   :width 300
                   :on-close :exit ;; Exits on close
                   :content &amp;#40;label :text &amp;quot;Hello this is a label!&amp;quot;&amp;#41;&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Now make the menu-item for the theme-selector. Also don't forget to add theme-select into :items in your jframe.&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&amp;#40;def theme-select &amp;#40;menu-item :text &amp;quot;Theme Select&amp;quot;
                               :tip &amp;quot;This will allow you to select a theme.&amp;quot;
                               :listen &amp;#91;:action handler&amp;#93;&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Now that you have the theme-select you can change your handler to do something when that is clicked on.&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&amp;#40;defn handler &amp;#91;event&amp;#93;
  &amp;#40;let &amp;#91;e &amp;#40;.getActionCommand event&amp;#41;&amp;#93;
    &amp;#40;if &amp;#40;= e &amp;quot;Close Frame&amp;quot;&amp;#41;
      &amp;#40;System/exit 0&amp;#41;&amp;#41;
    &amp;#40;if &amp;#40;= e &amp;quot;Theme Select&amp;quot;&amp;#41;  ;; add this to incorporate the theme selector.
      &amp;#40;-&amp;gt; &amp;#40;frame :title &amp;quot;Themes&amp;quot; :id 3 :content &amp;#40;theme-selector&amp;#41; :on-close :hide :height 600 :width 300&amp;#41; pack! show!&amp;#41;&amp;#41;&amp;#41;&amp;#41; ;; frame for the themes.
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Now we create the actual combobox that will select the theme.&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&amp;#40;defn theme-selector &amp;#91;&amp;#93;
  &amp;#40;horizontal-panel  
   :items &amp;#91;
           &amp;#40;combobox
            :model    &amp;#40;vals &amp;#40;SubstanceLookAndFeel/getAllSkins&amp;#41;&amp;#41; ;; list out all of the skins
            :renderer &amp;#40;fn &amp;#91;this {:keys &amp;#91;value&amp;#93;}&amp;#93;  ;; takes the values and displays them from all the skins.
                        &amp;#40;text! this &amp;#40;.getClassName value&amp;#41;&amp;#41;&amp;#41;
            :listen   &amp;#91;:selection &amp;#40;fn &amp;#91;e&amp;#93; 
                                    &amp;#40;invoke-later
                                     &amp;#40;-&amp;gt; e
                                         selection
                                         .getClassName
                                         SubstanceLookAndFeel/setSkin&amp;#41;&amp;#41;&amp;#41;&amp;#93;&amp;#41;&amp;#93;&amp;#41;&amp;#41; ;; changes the theme to the skin selected.
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Now you can open it up and go to file and select theme-selector which will allow you to change the theme!&lt;/p&gt;
</description>
<enclosure>

</enclosure>
<pubDate>
Wed, 31 Aug 2016 00:00:00 -0400
</pubDate>
</item>
<item>
<guid>
http://blogawesome.com/posts-output/2016-08-30-Using_Swing/
</guid>
<link>
http://blogawesome.com/posts-output/2016-08-30-Using_Swing/
</link>
<title>
Creating JFrames using Swing APIs in Clojure (Part 1)
</title>
<description>
&lt;p&gt;Swing is a powerful java library and also at times be complex however thanks to Dave Ray's &lt;a href='https://github.com/daveray/seesaw'&gt;seesaw&lt;/a&gt; which you should look at if you plan on doing any GUI building with Clojure.&lt;/p&gt;&lt;p&gt;I suggest reading the &lt;a href='https://gist.github.com/daveray/1441520'&gt;tutorial&lt;/a&gt; as well to get used to the basics.&lt;/p&gt;&lt;p&gt;But here I want to show you some things that aren't quite mentioned specifically in the tutorial. So lets create a new leiningen project.&lt;/p&gt;&lt;pre&gt;&lt;code&gt;$ lein new hello-swing
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This will create the leiningen project and now add the seesaw library to your projects.clj. Edit your project.clj file to include Seesaw. As well as adding where the main function will reside which will be in the hello-swing.core.&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&amp;#40;defproject hello-swing &amp;quot;0.1.0-SNAPSHOT&amp;quot;
  :description &amp;quot;FIXME: write description&amp;quot;
  :url &amp;quot;http://example.com/FIXME&amp;quot;
  :license {:name &amp;quot;Eclipse Public License&amp;quot;
            :url &amp;quot;http://www.eclipse.org/legal/epl-v10.html&amp;quot;}
  :dependencies &amp;#91;&amp;#91;org.clojure/clojure &amp;quot;1.8.0&amp;quot;&amp;#93;
                 &amp;#91;seesaw &amp;quot;1.4.2&amp;quot;&amp;#93;&amp;#93; ;; add this
  :main hello-swing.core&amp;#41; ;; add this
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Afterwards let start writing into our core.clj which is in the /src directory. Set up your core.clj as the following.&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&amp;#40;ns hello-swing.core
  &amp;#40;:gen-class&amp;#41;&amp;#41; ;; In case you want to make this into a jar.

&amp;#40;use 'seesaw.core&amp;#41; ;; allows you to use the seesaw library. However highly discouraged in production code.

&amp;#40;def jframe &amp;#40;frame :title &amp;quot;hello Frame&amp;quot;
                   :height 300 
                   :width 300
                   :on-close :exit ;; Exits on close you can also set it to :hide which will make the frame disappear.
                   :content &amp;#40;label :text &amp;quot;Hello this is a label!&amp;quot;&amp;#41;&amp;#41;&amp;#41; ;; A simple label with text.

&amp;#40;defn -main &amp;#91;&amp;#93;
  &amp;#40;native!&amp;#41;     ;; Makes the frame appear correctly based on the OS. Which should be called as soon as possible.
  &amp;#40;invoke-later ;; executes the body in the near future.
   &amp;#40;-&amp;gt; jframe show!&amp;#41;&amp;#41;&amp;#41; ;; displays the jframe.
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Now you can run the code by entering the following in the project directory.&lt;/p&gt;&lt;pre&gt;&lt;code&gt;$ lein run
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;You should see a frame like this.&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://defunsm.github.io/img/jframefirst.png&quot; alt=&quot;jframe&quot; /&gt;&lt;/p&gt;&lt;p&gt;Now that you made a frame pop up lets decorate the frame to be a little nicer. Adding a menubar to close it.&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&amp;#40;ns hello-swing.core
  &amp;#40;:gen-class&amp;#41;&amp;#41;

&amp;#40;use 'seesaw.core&amp;#41;

&amp;#40;defn handler &amp;#91;event&amp;#93;  ;; Handler that will be listening to the action commands being recieved.
  &amp;#40;let &amp;#91;e &amp;#40;.getActionCommand event&amp;#41;&amp;#93;
    &amp;#40;if &amp;#40;= e &amp;quot;Close Frame&amp;quot;&amp;#41;
      &amp;#40;System/exit 0&amp;#41;&amp;#41;&amp;#41;&amp;#41; ;; Exits the program with a exit status of 0.

&amp;#40;def close-frame &amp;#40;menu-item :text &amp;quot;Close Frame&amp;quot;
                            :tip &amp;quot;This will close the frame.&amp;quot;
                            :listen &amp;#91;:action handler&amp;#93;&amp;#41;&amp;#41;  ;; Assigning a function that will handle its action commands.

&amp;#40;def jframe &amp;#40;frame :title &amp;quot;hello Frame&amp;quot;
                   :menubar &amp;#40;menubar :items &amp;#91;&amp;#40;menu :text &amp;quot;File&amp;quot; :items &amp;#91;close-frame&amp;#93;&amp;#41;&amp;#93;&amp;#41; ;; adding a menubar
                   :height 300
                   :width 300
                   :on-close :exit ;; Exits on close
                   :content &amp;#40;label :text &amp;quot;Hello this is a label!&amp;quot;&amp;#41;&amp;#41;&amp;#41; ;; Label

&amp;#40;defn -main &amp;#91;&amp;#93;
  &amp;#40;native!&amp;#41;
  &amp;#40;invoke-later
   &amp;#40;-&amp;gt; jframe show!&amp;#41;&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;I think that'll be all for today since that in itself is a lot specially if you never worked with GUI's before. You can mess around and make the menubar do all kinds of things just by changing the (System/exit 0) part.&lt;/p&gt;&lt;p&gt;In the next part we will be doing themes.&lt;/p&gt;
</description>
<enclosure>

</enclosure>
<pubDate>
Tue, 30 Aug 2016 00:00:00 -0400
</pubDate>
</item>
<item>
<guid>
http://blogawesome.com/posts-output/2016-08-29-Clojure_GUI_as_an_Exe/
</guid>
<link>
http://blogawesome.com/posts-output/2016-08-29-Clojure_GUI_as_an_Exe/
</link>
<title>
Creating an Exechuteable GUI
</title>
<description>
 &lt;p&gt; Note: Before following this guide you may want to familiar yourself with &lt;a href='https://defunsm.github.io/posts-output/2016-08-28-jar/'&gt;making jars&lt;/a&gt;.   &lt;/p&gt;&lt;p&gt; You should have the uberjar which can be created by following a guide I have written previously.  Now you want to take it one step further and make the jar into an exe to distribute to different windows platforms. There is a few ways to go about it but I typically use &lt;a href='http://launch4j.sourceforge.net/'&gt;launch4j&lt;/a&gt;.  &lt;/p&gt;&lt;p&gt; After downloading Launch4j,&lt;/p&gt;&lt;p&gt;Step 1: &lt;/p&gt;&lt;p&gt;Open it up and fill in the output file and Jar field as the following. The output file determines what the .exe file will be called. While the jar field is the uber-jar you select and the launch4j will use to create the .exe file.  &lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://defunsm.github.io/img/launch4jfirst.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;&lt;p&gt;Step 2: &lt;/p&gt;&lt;p&gt;After filling those fields switch to the header tab. Click on the GUI radio button unless you're using just console.  &lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://defunsm.github.io/img/launch4jsecond.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;&lt;p&gt;Step 3: &lt;/p&gt;&lt;p&gt;Click the JRE tab and enter Min JRE version as what minimum java you need to run the code.  Also click the + property button by variables / registry field to add the EXEDIR property.&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://defunsm.github.io/img/launch4jthird.png&quot; alt=&quot;image&quot; /&gt; &lt;/p&gt;&lt;p&gt;Now click on build wrapper which is the  gear icon on top and it should build your .exe file!&lt;/p&gt;
</description>
<enclosure>

</enclosure>
<pubDate>
Mon, 29 Aug 2016 00:00:00 -0400
</pubDate>
</item>
<item>
<guid>
http://blogawesome.com/posts-output/2016-08-28-jar/
</guid>
<link>
http://blogawesome.com/posts-output/2016-08-28-jar/
</link>
<title>
Clojure File to Standalone Jar
</title>
<description>
&lt;p&gt;Clojure luckily relies on the JVM and thus it is easy to turn a .clj into a .jar with relative ease. Of course there are some things you have to watch out for such as making sure that the -main function contains everything and nothing is in the top level that's supposed to be in the -main function.&lt;/p&gt;&lt;p&gt;So start with the basics start a leiningen project running the following.&lt;/p&gt;&lt;pre&gt;&lt;code&gt;$ lein new defunsmproject
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This will create a new leiningen project which now means you should have a project.clj file. That looks something like this.&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&amp;#40;defproject defunsmproject &amp;quot;0.1.0-SNAPSHOT&amp;quot;
  :description &amp;quot;FIXME: write description&amp;quot;
  :url &amp;quot;http://example.com/FIXME&amp;quot;
  :license {:name &amp;quot;Eclipse Public License&amp;quot;
            :url &amp;quot;http://www.eclipse.org/legal/epl-v10.html&amp;quot;}
  :dependencies &amp;#91;&amp;#91;org.clojure/clojure &amp;quot;1.8.0&amp;quot;&amp;#93;&amp;#93;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Your core.clj should look like this which is located in the src directory of the leiningen project directory. &lt;/p&gt;&lt;pre&gt;&lt;code&gt;&amp;#40;ns defunsmproject.core&amp;#41;

&amp;#40;defn foo
  &amp;quot;I don't do a whole lot.&amp;quot;
  &amp;#91;x&amp;#93;
  &amp;#40;println x &amp;quot;Hello, World!&amp;quot;&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Step 1: Edit project.clj so that leiningen knows which one is your -main function.  In this cause it would be defunsmproject.core.&lt;/p&gt;&lt;p&gt;As well as adding :profiles telling leiningen how to build the jar file.&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&amp;#40;defproject defunsmproject &amp;quot;0.1.0-SNAPSHOT&amp;quot;
  :description &amp;quot;FIXME: write description&amp;quot;
  :url &amp;quot;http://example.com/FIXME&amp;quot;
  :license {:name &amp;quot;Eclipse Public License&amp;quot;
            :url &amp;quot;http://www.eclipse.org/legal/epl-v10.html&amp;quot;}
  :dependencies &amp;#91;&amp;#91;org.clojure/clojure &amp;quot;1.8.0&amp;quot;&amp;#93;&amp;#93;
  :profiles {:uberjar {:aot &amp;#91;defunsmproject.core&amp;#93;}} ;; add this
  :jar-name &amp;quot;defunsmproject.jar&amp;quot; ;; add this
  :uberjar-name &amp;quot;defunsmproject-uber.jar&amp;quot; ;; add this
  :main defunsmproject.core&amp;#41; ;; add this
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Step 2: Add :gen-class and -main function in the core.clj.&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&amp;#40;ns defunsmproject.core
  &amp;#40;:gen-class&amp;#41;&amp;#41; ;; add this gen-class

&amp;#40;defn -main &amp;#91;&amp;amp; args&amp;#93;  ;; add this -main function
  &amp;#40;println &amp;quot;Converting a clojure file to a standalone jar!&amp;quot;&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Step 3: Now you can make a uberjar which is the standalone jar by running ...&lt;/p&gt;&lt;pre&gt;&lt;code&gt;$ lein uberjar
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;If that worked than your in good luck and should have a uber-jar and a jar. The standalone one that you probably want is the uber-jar one which will be in the the target directory that was generated.&lt;/p&gt;&lt;p&gt;To run the jar file do the following. And you should see the output as expected.&lt;/p&gt;&lt;pre&gt;&lt;code&gt;$ java -jar defunsmproject-uber.jar
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;If you run into problems make sure that your project.clj and core.clj is set up just like mine. Otherwise you now have a .jar file from a .clj file!&lt;/p&gt;
</description>
<enclosure>

</enclosure>
<pubDate>
Sun, 28 Aug 2016 00:00:00 -0400
</pubDate>
</item>
<item>
<guid>
http://blogawesome.com/posts-output/2016-08-27-new/
</guid>
<link>
http://blogawesome.com/posts-output/2016-08-27-new/
</link>
<title>
A New Beginning
</title>
<description>
 &lt;p&gt; This is a post to clerify the usage of this site. One this site was created in order to demonstrate the knowledge that I will accumulate over time during my time in college. Two I accidently deleted all my web files from the previous site I was worked on over the past year (3 AM and I actually did the rm -rf command and I also deleted my backup files thinking I didnt need them. Yeah.) Hopefully this one will be even better than the previous one. Third I'll be posting guides and once in a blue moon something more intimate. I think that's all I'm going to type since I been going on with 4 hours of sleep this entire day... night.  &lt;/p&gt;
</description>
<enclosure>

</enclosure>
<pubDate>
Sat, 27 Aug 2016 00:00:00 -0400
</pubDate>
</item>
</channel>
</rss>
